#!/usr/bin/env python3

import json
import sys
import re
import statistics

with open(sys.argv[1], "r") as f:
    json_data = json.loads(f.read())

if len(sys.argv) > 2:
    key_type, value_type = sys.argv[2].split("/")
else:
    key_type = "freq"
    value_type = "power"

if len(sys.argv) > 3:
    old_model = {"core": [], "cluster": []}

    # Example:
    # {
    #     "core": [
    #         {
    #             "busy": [1, 2, 3, 4, 5, 6],
    #             "idle": [3, 2, 1],
    #         },
    #         {
    #             "busy": [10, 20, 30, 40, 50, 60],
    #             "idle": [5, 3, 2],
    #         },
    #     ],
    #     "cluster": [
    #         {
    #             "busy": [1, 1, 1, 2, 3, 3],
    #             "idle": [2, 2, 1],
    #         },
    #         {
    #             "busy": [2, 2, 3, 4, 4, 5],
    #             "idle": [4, 2, 1],
    #         },
    #     ],
    # }

    with open(sys.argv[3], "r") as f:
        old_dtsi = f.read().split("\n")

    # Rudimentary line-by-line DTS parser, will break with unexpected data
    cpu_i = -1
    data_block = None
    cost_block = None
    for line in old_dtsi:
        match = re.search(r"(core|cluster)-cost(\d+)\s+\{", line)
        if match:
            new_data_block = match.group(1)
            if new_data_block == data_block:
                cpu_i += 1
            else:
                cpu_i = 0

            data_block = new_data_block
            old_model[data_block].append({})
            continue

        match = re.search(r"(busy|idle)-cost-data\s+=", line)
        if match:
            cost_block = match.group(1)
            old_model[data_block][cpu_i][cost_block] = []
            continue

        if cost_block == "busy":
            match = re.search(r"^\s*(\d+)\s+(\d+)\s*$", line)
            if match:
                key = int(match.group(1))
                value = int(match.group(2))

                # Ignore keys (cap/freq) and use indices instead
                # Assumption: all freqs are present in both
                old_model[data_block][cpu_i]["busy"].append(value)
        elif cost_block == "idle":
            if re.match(r"^\s*(?:\d+\s*)+$", line):
                # Extend array to accomodate single-line costs, e.g. qcom format
                idle_costs = [int(cost) for cost in re.split(r"\s+", line.strip())]
                old_model[data_block][cpu_i]["idle"] += idle_costs

        if re.match(r"^\s*>;\s*$", line):
            cost_block = None
else:
    old_model = None

cpus_data = json_data["cpus"]
DTS_HEADER = """/*
 * Auto-generated legacy EAS energy model for incorporation in SoC device tree.
 * Generated by freqbench postprocessing scripts using freqbench results.
 * More info at https://github.com/kdrag0n/freqbench
 */

/ {
\tcpus {"""

print(DTS_HEADER, end="")

# Performance efficiency
unscaled_cpu_cm_mhz = {}
for cpu, cpu_data in cpus_data.items():
    last_freq, last_freq_data = max(cpu_data["freqs"].items(), key=lambda f: f[0])
    cm_mhz = last_freq_data["active"]["coremarks_per_mhz"]
    unscaled_cpu_cm_mhz[int(cpu)] = cm_mhz

# Scale performance efficiency
max_cm_mhz = max(unscaled_cpu_cm_mhz.values())
scaled_cpu_cm_mhz = {
    cpu: cm_mhz / max_cm_mhz * 1024
    for cpu, cm_mhz in unscaled_cpu_cm_mhz.items()
}

# Pass 1: performance efficiency (for capacity scaling)
for cpu, cpu_data in cpus_data.items():
    cpu = int(cpu)

    cm_mhz_norm = scaled_cpu_cm_mhz[cpu]

    lb = "{"
    rb = "}"
    print(f"""
\t\tcpu@{0 if cpu == 1 else cpu} {lb}
\t\t\tefficiency = <{cm_mhz_norm:.0f}>;
\t\t\tcapacity-dmips-mhz = <{cm_mhz_norm:.0f}>;
\t\t{rb};""")

print("""\t};

\tenergy_costs: energy-costs {
\t\tcompatible = "sched-energy";""")

max_perf = max(
    max(freq["active"]["coremark_score"]
    for freq in cpu["freqs"].values()) for cpu in cpus_data.values()
)

# Pass 2: core costs
core_cost_keys = []
for cpu_i, (cpu, cpu_data) in enumerate(cpus_data.items()):
    cpu = int(cpu)
    core_cost_keys.append([])

    lb = "{"
    rb = "}"
    print(f"""
\t\tCPU_COST_{cpu_i}: core-cost{cpu_i} {lb}
\t\t\tbusy-cost-data = <""")

    for freq, freq_data in cpu_data["freqs"].items():
        freq = int(freq)

        if value_type == "power":
            value = freq_data["active"]["power_mean"]
        elif value_type == "energy":
            value = freq_data["active"]["energy_millijoules"]

        if key_type == "freq":
            key = freq
            print(f"\t\t\t\t{key: 8.0f}{value: 5.0f}")
        elif key_type == "cap":
            # Floor to match CPU integer math
            key = freq_data["active"]["coremark_score"] / max_perf * 1024
            print(f"\t\t\t\t{key: 5.0f}{value: 5.0f}")

        core_cost_keys[cpu_i].append(key)

    if old_model:
        idle_costs = " ".join(map(str, old_model["core"][cpu_i]["idle"]))
    else:
        # Placeholder in lieu of real data
        idle_costs = "3 2 1"

    print(f"""\t\t\t>;
\t\t\tidle-cost-data = <
\t\t\t\t{idle_costs}
\t\t\t>;
\t\t{rb};""")

# Pass 3: cluster costs
if old_model:
    for cpu_i, new_keys in enumerate(core_cost_keys):
        lb = "{"
        rb = "}"
        print(f"""
\t\tCLUSTER_COST_{cpu_i}: cluster-cost{cpu_i} {lb}
\t\t\tbusy-cost-data = <""")

        for cost_i, cost in enumerate(old_model["cluster"][cpu_i]["busy"]):
            # Ignore silently for now instead of logging to stderr to make copy-pasting easier
            # This happens with qcom speed bin differences on newer SoCs
            if cost_i >= len(new_keys):
                continue

            key = new_keys[cost_i]
            print(f"\t\t\t\t{key: 5.0f}{cost: 5.0f}")

        idle_costs = " ".join(map(str, old_model["cluster"][cpu_i]["idle"]))

        print(f"""\t\t\t>;
\t\t\tidle-cost-data = <
\t\t\t\t{idle_costs}
\t\t\t>;
\t\t{rb};""")

print("""\t};
};""")
